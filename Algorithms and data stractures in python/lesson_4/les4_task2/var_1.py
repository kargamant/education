#С использованием решета эратосфена через цикл

def sieve(el):
    #n - граница массива.
    #она определяется введённым номером i-ого элемента
    # и позже в цикле увеличивается на его удвоенное значение.
    #Это помогает увеличить скорость алгоритма так,
    # чтобы не сильно нагрузить генератор решета и при этом сэкономить на количестве итераций цикла.
    n = el
    while True:
        #алгоритм решета Эратосфена
        sieve = [i  for i in range(n)]
        sieve[1] = 0
        for i in range(2, n):
            if i != 0:
                k = i*2
                while k < n:
                    sieve[k] = 0
                    k += i
        #Генерация массива с  простыми числами до n
        result = [i for i in sieve if i != 0]
        # Проверка на существование значения i-ого элемента в массиве result
        # если индекс последнего элемента массива меньше порядкового номера искомого элемента,
        # то его там нет.
        if len(result)-1 >= el-1:
            return result[el-1]
        n += el * 2
#Тесты
'''
"var_1.prime(10)"
1000 loops, best of 5: 14.8 usec per loop

"var_1.prime(100)"
1000 loops, best of 5: 1.13 msec per loop

"var_1.prime(500)"
1000 loops, best of 5: 12.2 msec per loop

Профилизация не делается, т.к. известно, что функция будет вызвана всего один раз
'''

'''
Вывод: быстрее всего работают способы, использующие решето Эратосфена. Само решето Эратосфена имеет сложность O(nlog(logn)),
что позволяет справляться с поиском простых чисел максимально быстро. В целом алгоритм по поиску i-ого простого числа выполняется достаточно быстро,
т.к. за границу решета я взял i-ый элемент и позже в цикле удваивал его. Это помогает увеличить скорость алгоритма так,
чтобы не сильно нагрузить генератор решета и при этом сэкономить на количестве итераций цикла.
'''
#4. Найти сумму n элементов следующего ряда чисел: 1, -0.5, 0.25, -0.125,…

from cProfile import run
#from functools import lru_cache

#Вариант 1 - рекурсивный способ без использования мемоизации
#Количество элементов (n) ,для корректного определения времени работы алгоритма, будет задаваться аргументом в функции.

#@lru_cache()
def sum_el(n):
    #Базовый случай
    if n == 1:
        return n
    # Рекурсивный случай
    return (-0.5) ** (n-1) + sum_el(n-1)

#Функция-тест
def test_sum(func):
    summs = [1, 0.5, 0.75, 0.625, 0.6875]
    for i, item in enumerate(summs):
        assert item == func(i+1)
        print(f'sum {i+1} - OK')
    return 'success'

#проверка работы функции print(test_sum(sum_el))

'''
Профилизация
tests = [10, 100, 500]
for i in tests:
    run(f'sum_el({i})')
'''

#Тесты
'''
"var_1.sum_el(10)"
1000 loops, best of 5: 6.52 usec per loop
С использованием встроенной мемоизации
"var_1.sum_el(10)"
1000 loops, best of 5: 123 nsec per loop
Результат профилизации
22 function calls (13 primitive calls) in 0.000 seconds
10 ncalls

"var_1.sum_el(100)"
1000 loops, best of 5: 45.5 usec per loop
С использованием встроенной мемоизации
"var_1.sum_el(100)"
1000 loops, best of 5: 152 nsec per loop
Результат профилизации
202 function calls (103 primitive calls) in 0.000 seconds
100 ncalls

"var_1.sum_el(500)"
1000 loops, best of 5: 249 usec per loop
С использованием встроенной мемоизации
Переполнение стека вызовов
Результат профилизации
1002 function calls (503 primitive calls) in 0.001 seconds
500 ncalls
'''
'''Вывод: 
Данный алгоритм со сложностью O(n) работает быстро, однако ограничен лимитом стека вызовов,
поэтому не подходит для работы с большим объёмом данных.
Со встроенным инструментом мемоизации работает намного быстрее, 
но лимит стека вызовов достигается уже на аргументе 500 и выше.
Он малоэффективен для решения этого задания.
'''
#Пометка насчёт встроенной мемоизации
'''
Инструмент lru_cache даёт значительный прирост в скорости, однако он не спасёт от переполнения стека вызова функции,
а также довольно требовательный к ресурсам компьютера. Результаты тестов с его участием зачастую необъективны, поэтому я
решил не рассматривать алгоритм с ним как отдельный вариант решения.
'''